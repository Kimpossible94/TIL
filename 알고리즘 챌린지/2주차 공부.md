# 검색 알고리즘
## 선형 검색
요소가 직선 모양으로 늘어진 배열에서의 검색은 원하는 키 값을 갖는 요소를 만날 때까지 맨 앞부터 순서대로 요소를 검색하는데  
이것이 선형 검색 또는 순차 검색이라는 알고리즘이다.  
<br>
요소가 4개인 배열을 검색은 다음과 같이 진행된다.  
```
첫 번째 요소 검색 (원하는 값 X) -> 두 번째 요소 검색 (원하는 값 X) -> 세 번째 요소 검색 (원하는 값 X) -> 네 번째 요소 검색 (원하는 값 O) -> 검색 성공


첫 번째 요소 검색 (원하는 값 X) -> 두 번째 요소 검색 (원하는 값 X) -> 세 번째 요소 검색 (원하는 값 X) -> 네 번째 요소 검색 (원하는 값 X) -> 검색 실패
```
위의 과정을 보면 배열의 검색 종료 조건은 2개인 것을 알 수있다.  
1. 검색할 값과 같은 요소를 발견한 경우
2. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우

### 보초법
선형 검색은 반복마다 위에서 언급한 2개의 종료 조건을 검색한다. 단순한 판단같지만 반복횟수가 많아진다면 종료 조건을 검사하는 비용을 무시할 수 없게된다.  
이 비용을 반절로 줄이는 방법을 **보초법**이라고 한다.  
<br>
보초법은 말대로 배열의 끝이 보초를 세우는 것을 말한다. 예를 들어보자.  
```
{1, 3, 5, 6, 9, 0}
```
위와 같은 배열에서 숫자 2를 찾기 위해 선형 검색을 한다고하자.  
그럼 요소마다 배열의 끝인지를 검사하고 숫자 2인지를 검사한다. 이러한 비용을 줄이기 위해 아래처럼 배열의 맨 뒤에 목표하는 데이터를 넣어보자.  
```
{1, 3, 5, 6, 9, 0, 2}
```
이렇게 된다면 반복마다 종료 조건 중 하나인 배열의 끝인지를 확인할 필요가 없게된다.  
검색의 종료 조건은 찾으려는 데이터가 맞는지만 검사하고 검색종료 후 찾은 요소가 보초인지만 판단하면 된다.  
<br>
결과적으로 아래처럼 프로그램을 만들면 된다.
```java
public static void main (String[] args) {
    Scanner sc = new Scanner(System.in);
    // 요소수
    int num = sc.nextInt();
    int[] arr = new int[num + 1];

    for (int i = 0; int < num; i++){
        arr[i] = sc.nextInt();
    }

    // 찾으려는 값
    int wantNum = sc.nextInt();

    int result = findWantNum(arr, num, wantNum);

    if(result != -1) System.out.println("원하는 값은 " + result + "번 째에 있습니다.");
}

private int findWantNum(int[] arr, int num, int wantNum) {
    int i = 0;
    arr[num] = wantNum;

    while(true) {
        if(arr[i] == wantNum) break;
        i++;
    }

    // i가 num과 같다면 보초이므로 -1 반환
    return i == num ? -1 : i;
}
```

<br>
<br>

## 이진 검색
이진 검색 알고리즘을 적용하는 전제 조건은 데이터가 키 값으로 이미 정렬되어 있다는 것이다.  
이진 검색은 선형 검색보다 좀 더 빠르게 검색할 수 있다는 장점이 있다.  
  
이진 검색은 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘이다.  
아래의 그림으로 이진 검색의 방법에 대해 알아보자.  
![이진검색1](이미지/이진검색(1).png)  
사진과 같은 배열이 있고, 찾으려는 값은 39라고 하자.  
우선 이진 검색은 배열의 중앙에 위치한 요소(arr[5])인 31부터 검색을 시작한다.  
찾으려는 값인 39는 검색한 중앙값인 31보다 크기 때문에 arr[0] ~ arr[5]까지의 요소는 검색할 필요가 없게 된다.
![이진검색2](이미지/이진검색(2).png)  
그러므로 위 사진처럼 검색 범위에서 제외시키고 제외시키고 남은 배열에서 중앙값(arr[8])을 다시 검색한다.  
검색한 중앙값은 찾으려는 값인 39보다 작기 때문에 arr[8] ~ arr[10]까지는 다시 검색범위에서 제외된다.  
![이진검색3](이미지/이진검색(3).png)  
둘 중 아무거나 선택해도 상관없지만 앞 쪽의 39를 선택하여 원하는 값인지를 확인한다.  
(남아있는 검색 범위(arr[6] ~ arr[7])의 중앙값을 구하기위해 (6 + 7)/2를 하므로 6번 인덱스를 검사한다.)  
![이진검색4](이미지/이진검색(4).png)  
검색한 39는 찾으려는 값과 일치하므로 검색이 성공해 종료된다.  
  
결과적으로 이진 검색의 종료 조건은 아래와 같이 2개가 있다.
1. 검색할 값과 같은 요소를 발견한 경우
2. 검색 범위가 더이상 없는 경우

  
결과적으로 이진 검색을 이용한 프로그램은 아래처럼 만들면 된다.  
```java
public static void main (String[] args) {
    Scanner sc = new Scanner(System.in);

    // 요소수
    int num = sc.nextInt();
    int arr = new int[num];

    arr[0] = sc.nextInt();
    
    // 오름차순으로 입력하기 위해 입력한 값이 이전 인덱스보다 작다면 다시 입력하도록 구현
    for(int i = 1; i < num; i++) {
        do {
            arr[i] = sc.nextInt();
        } while (arr[i] < x[i - 1])
    }

    // 찾으려는 값 입력
    int key = sc.nextInt();

    int result = binarySearch(arr, num, key);
}

public static int binarySearch(int[] arr, int num, int key) {
    // 검색 범위의 첫 인덱스
    int pl = 0;
    // 검색 범위의 마지막 인덱스
    int pr = num - 1;

    do {
        // 검색 범위의 중앙 인덱스
        int pc = (pl + pr) / 2;
        
        // 검색 성공
        if (arr[pc] == key) return pc
        else if(arr[pc] < key) {
            // 중앙값이 찾으려는 값보다 작은 경우 검색 범위를 중앙값의 뒤쪽으로 설정
            pl = pc + 1;
        }
        else {
            // 중앙값이 찾으려는 값보다 큰 경우 검색 범위를 중앙값의 앞쪽으로 설정
            pr = pc - 1;
        } while (pl <= pr);

        // 검색 실패
        return -1;
    }
}
```

<br>
<br>

## 복잡도
프로그램의 실행 속도는 하드웨어나 컴파일러 등의 여러 조건에 따라서 달라진다.  
그래서 알고리즘의 성능을 객관적으로 평가하는 기준이 필요한데 이 것을 복잡도라고 한다.  
  
복잡도는 아래의 두 가지 요소를 가지고 있다.  
```
1. 시간 복잡도 : 실행에 필요한 시간을 평가한 것
2. 공간 복잡도 : 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것
```
<br>

### 선형 검색의 시간복잡도 계산  
  
이제 앞에서 선형 검색과 이진 검색의 시간 복잡도를 알아보자.  
```java
private int findWantNum(int[] arr, int num, int wantNum) {
    int i = 0; // 1

    while(i < num) { // 2
        if(arr[i] == key ) { // 3
            return i; // 4
        }
        i++; // 5
    }
    return -1; // 6
}
```

붙여놓은 번호를 하나씩 보자.   
1번은 i에 0을 대입하는 동작이다. 이는 처음에 1번만 실행된다.  
이렇게 한 번만 실행하는 경우 시간 복잡도는 O(1)이다.  
  
2번은 배열의 맨 끝인지 판단하는 동작인데 평균 실행 횟수는 num/2 번이고 3번과 5번 역시 평균 실행횟수는 num/2번 이다.  
이런 경우 시간복잡도는 O(n)이다.  
* 평균 실행횟수가 num/2 번일 때 시간복잡도가 O(n/2)가 아닌 이유는 n의 값이 무한대로 커진다고 했을 때 그 값의 차이가 미미해지기 때문이다.  
* 마찬가지로 100번 실행할 때 O(100)이 아니라 O(1)로 표기하는데 컴퓨터에게 계산하는 시간의 차이는 사람이 느낄 수 없을 정도로 굉장히 작기 때문이다.
  
4번은 한 번만 return하므로 시간 복잡도는 O(1)이다.  
6번도 한 번만 실행되므로 O(1)이다.  
  
일반적으로 O(f(n))과 O(g(n))의 복잡도 계산하는 방법은 아래와 같다.
```
O(f(n)) + O(g(n)) = O(max(f(n), g(n)))
```

2개 이상의 복잡도로 구성된 알고리즘의 전체 복잡도는 차원이 더 높은 쪽의 복잡도를 우선시 한다.  
따라서 위에서 적은 선형 검색의 알고리즘 복잡도를 구하면 아래와 같다.
```
O(1) + O(n) + O(n) + O(1) + O(n) + O(1) = O(max(1, n, n, 1, n, 1)) = O(n)
```
즉, 선형 검색의 알고리즘 복잡도는 O(n)이다.  

<br>

### 이진 검색의 시간 복잡도 계산
이제 이진 검색의 시간 복잡도를 계산해보자.




