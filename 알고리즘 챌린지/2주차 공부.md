# 검색 알고리즘
## 선형 검색
요소가 직선 모양으로 늘어진 배열에서의 검색은 원하는 키 값을 갖는 요소를 만날 때까지 맨 앞부터 순서대로 요소를 검색하는데  
이것이 선형 검색 또는 순차 검색이라는 알고리즘이다.  
<br>
요소가 4개인 배열을 검색은 다음과 같이 진행된다.  
```
첫 번째 요소 검색 (원하는 값 X) -> 두 번째 요소 검색 (원하는 값 X) -> 세 번째 요소 검색 (원하는 값 X) -> 네 번째 요소 검색 (원하는 값 O) -> 검색 성공


첫 번째 요소 검색 (원하는 값 X) -> 두 번째 요소 검색 (원하는 값 X) -> 세 번째 요소 검색 (원하는 값 X) -> 네 번째 요소 검색 (원하는 값 X) -> 검색 실패
```
위의 과정을 보면 배열의 검색 종료 조건은 2개인 것을 알 수있다.  
1. 검색할 값과 같은 요소를 발견한 경우
2. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우

### 보초법
선형 검색은 반복마다 위에서 언급한 2개의 종료 조건을 검색한다. 단순한 판단같지만 반복횟수가 많아진다면 종료 조건을 검사하는 비용을 무시할 수 없게된다.  
이 비용을 반절로 줄이는 방법을 **보초법**이라고 한다.  
<br>
보초법은 말대로 배열의 끝이 보초를 세우는 것을 말한다. 예를 들어보자.  
```
{1, 3, 5, 6, 9, 0}
```
위와 같은 배열에서 숫자 2를 찾기 위해 선형 검색을 한다고하자.  
그럼 요소마다 배열의 끝인지를 검사하고 숫자 2인지를 검사한다. 이러한 비용을 줄이기 위해 아래처럼 배열의 맨 뒤에 목표하는 데이터를 넣어보자.  
```
{1, 3, 5, 6, 9, 0, 2}
```
이렇게 된다면 반복마다 종료 조건 중 하나인 배열의 끝인지를 확인할 필요가 없게된다.  
검색의 종료 조건은 찾으려는 데이터가 맞는지만 검사하고 검색종료 후 찾은 요소가 보초인지만 판단하면 된다.  
<br>
결과적으로 아래처럼 프로그램을 만들면 된다.
```java
public static void main (String[] args) {
    Scanner sc = new Scanner(System.in);
    // 요소수
    int num = sc.nextInt();
    int[] arr = new int[num + 1];

    for (int i = 0; int < num; i++){
        arr[i] = sc.nextInt();
    }

    // 찾으려는 값
    int wantNum = sc.nextInt();

    int result = findWantNum(arr, num, wantNum);

    if(result != -1) System.out.println("원하는 값은 " + result + "번 째에 있습니다.");
}

private int findWantNum(int[] arr, int num, int wantNum) {
    int i = 0;
    arr[num] = wantNum;

    while(true) {
        if(arr[i] == wantNum) break;
        i++;
    }

    // i가 num과 같다면 보초이므로 -1 반환
    return i == num ? -1 : i;
}
```

## 이진 검색
이진 검색 알고리즘을 적용하는 전제 조건은 데이터가 키 값으로 이미 정렬되어 있다는 것이다.  
이진 검색은 선형 검색보다 좀 더 빠르게 검색할 수 있다는 장점이 있다.  
  
이진 검색은 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘이다.  
아래의 그림으로 이진 검색의 방법에 대해 알아보자.  
![이진검색1](이미지/이진검색(1).png)  
사진과 같은 배열이 있고, 찾으려는 값은 39라고 하자.  
우선 이진 검색은 배열의 중앙에 위치한 요소(arr[5])인 31부터 검색을 시작한다.  
찾으려는 값인 39는 검색한 중앙값인 31보다 크기 때문에 arr[0] ~ arr[5]까지의 요소는 검색할 필요가 없게 된다.