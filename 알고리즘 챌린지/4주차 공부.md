# 재귀 알고리즘
## 팩토리얼 구하기
팩토리얼을 재귀를 이용해 구하면서 재귀의 개념에 대해 알아보자.  
음이 아닌 정수n의 팩토리얼(n!)은 아래처럼 재귀적으로 정의할 수 있다.  
```
1. 0! = 1
2. n > 0이면 n! = n * (n - 1)!
```
위의 정의를 그대로 프로그램으로 구현하면 아래와 같다.
```java
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    int n = sc.nextInt();

    factorial(n);
}

public static int factorial(int n) {
    if (n > 0) {
        return n * factorial(n - 1);
    } else {
        return 1;
    }
}
``` 
위 코드에서 n값이 3이라고 가정하면 아래처럼 될 것이다.  
3 * factorial(2) * factorial(1) * factorial(0)  
3 * factorial(2) * factorial(1) * 1  
3 * factorial(2) * 1 * 1  
3 * 2 * 1 * 1 = 6  
  
## 직접 재귀와 간접 재귀
위의 팩토리얼 구하기처럼 자시 자신을 호출하여 작업을 수행하는 방법을 직접 재귀라고 한다.  
간접 재귀는 메서드 a, b가 있을 때 a에서 b를 호출하고 b에서 다시 a를 호출하는 구조를 말한다.  

## 유클리드 호제법
유클리드 호제법은 두개의 양의 정수 혹은 두 다항식의 최대공약수를 구하는 방법을 말한다.  
```
두 양의 정수 a,b(a > b)에 대하여 a = bq + r (0 ≤ r < b)라 하면 a,b의 최대공약수는 b,r의 최대 공약수와 같다.
즉, gcd(a, b) = gcd(b, r)
r = 0이라면 a,b의 최대공약수는 b가 된다.
```
위의 내용이 유클리드 호제법을 정의한 내용이다. 정의를 이해하기 위해 정리해보자.  
1. 두 양의 정수 A,B(A > B)가 있다. 큰 수인 A에서 B를 나눈다면 아래와 같이 표현할 수 있다.  
A = B * Q + R  
R은 A와 B를 나눈 나머지이며 Q는 몫이다.
2. 이때 A와 B의 최대공약수를 Q라고 가정하면 A = a * Q , B = b * Q (a와 b는 서로소)가 성립된다.  
3. 이 것을 위의 R에 대입해 정리하면 아래와 같다.  
R = aG - bGQ = (a - bQ)G  
그리고 아까 위에서 언급한걸 보면  
B = bG  
R과 B 모두 G라는 공통의 약수를 가지고 있다.  
4. 이제 R과 B에 있는 G라는 약수가 최대공약수가 되는지 확인해야한다.  
그래야 A,B의 최대공약수가 B, R의 최대공약수 라는 것이 증명되기 때문이다.  
그러면 (a - bG)와 b가 서로소라는 것을 증명하면 된다. (서로소는 두 수의 최대공약수가 1인 것을 서로소라고 말한다.)  
5. 서로소가 아니다라는 가정으로 접근해보자. 이 가정이 틀렸다면 서로소이기 때문이다.  
두 수가 서로소가 아니라고 가정했으니 1보다 큰 최대공약수(T)가 존재한다는 말이 된다.  
a - bQ = MT , b = NT  
b를 대입하면 a - NTQ = MT 이렇게 된다. 이걸 변형시키면 아래와 같다.  
a = MT + NTQ = T(M + NQ)  정리하면 아래와 같다.  
a = (M + NQ)T  
b = NT  
여기에서 모순이 생긴다 a와 b는 서로소이어야 한다.  
1보다 큰 최대공약수인 T를 약수로 가지고 있으므로 서로소가 아니게 된다.  
그렇다면 애초에 1보다 큰 최대공약수인 T를 가지고있다는 가정이 틀린것이 되므로 a와 b는 서로소라는 것이 증명된다.
6. 이렇게 최대공약수를 구하는 방법이 유클리드 호제법이다.  
바로 최대공약수 계산이 안되는 예를 들어 A = 1980, B = 168이라 했을 때 위의 공식을 이용해  
A = B * Q + R  
1980 = 168 * 11 + 132 (Q는 나눗셈의 몫, R은 나머지)로 나타낼 수 있다.  
그 다음 B인 168과 R인 132의 최대 공약수가 A인 1980과 B인 168과의 최대 공약수와 같다고 했으므로 최대공약수를 구해주면 되는데 아직도 구하기 어렵다.  
그렇다면 다시 공식을 사용하면 된다.  
168 = 132 * 1 + 36 이 된다 이 방식을 계속 진행해보자.  
132 = 36 * 3 + 24  
36 = 24 * 1 + 12  
24 = 12 * 2 + 0  
이렇게 마지막에는 나머지가 0이 된다. 이렇게 나머지가 0이 되었을 때의 다음은 A가 12 B가 0이 될 것이다. 여기서 0은 모든 수의 약수가 아니므로 A인 12가 최종적으로 A와 B의 최대공약수가 된다.  

### 유클리드 호제법 구현
유클리드 호제법에 대해 알아봤으니 이제 이 것을 코드로 만들어보자.  
구현 방법은 간단하다. 정수 a와 b를 입력받고 두 개를 나누고 남은 나머지를 다시 b로 그리고 b를 a로 만들어 나머지가 0이 될때까지 나눗셈을 하면된다.  
```java
public static int gcd(int a, int b) {
    if(b == 0) return a;
    else return gcd(a, b % a);
}

public static void main (String[] args) {
    Scanner sc = new Scanner(System.in);

    int a = sc.nextInt();
    int b = sc.nextInt();

    while (b > a || a == b) {
        a = sc.nextInt();
        b = sc.nextInt();
    }

    int res = gcd(a, b);
}
```

## 재귀 알고리즘 분석
재귀 알고리즘을 분석하기 위한 하향식, 상향식 분석을 알아보자.  

### 예제
```java
public static void recur(int n) {
    if (n > 0) {
        recur(n - 1);
        System.out.println(n);
        recur(n - 2);
    }
}

public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();

    recur(n);
}
```

recur 메서드는 안에서 재귀 호출을 2회 실행한다. 이처럼 재귀 호출을 여러 회 실행하는 메서드를 순수하게(genuinely) 재귀적이라 하며 실제 동작은 매우 복잡하다.  
이 메서드를 하향식과 상향식 2가지 방법으로 분석해보자.  

### 하향식 분석
처음 recur(n)을 실행하면 아래과 같이 동작할 것이다.
```
1. recur(n - 1)을 실행한다.
2. n을 출력한다.
3. recure(n - 2)을 실행한다.
```
물론 2에서 n을 출력하는 것은 recur(n - 1)에 대한 실행이 완료된 이후이다.  
n이 4라고 가정하고 아래의 그림을 보자.  

![하향식분석](이미지/하향식분석.png) 
1. 각각을 하나의 작업으로 보고 각각의 상자는 작업의 세부단위라고 생각하자. 
2. 작업의 세부 단위는 왼쪽부터 오른쪽으로 실행된다고 생각하자.  
3. 세부 단위에 화살표로 연결된 작업이 있다면 그 작업먼저 실행해야 한다. 
4. 빈 상자를 만나면 아무것도 하지않고 다음 작업 세부 단위를 실행한다.
5. 모든 세부 단위를 실행해야 호출한 작업으로 돌아갈 수 있다.

recur(4)는 아래와 같은 순서로 실행될 것이다.  
```
1. recur(3) 실행 -> recur(2) 실행 -> recur(1)실행
2. 빈 상자를 만남 -> 1을 출력 -> 빈 상자 -> 이전 작업으로 돌아감
3. 2를 출력 -> 빈 상자 -> 이전 작업으로 돌아감
4. 3을 출력 -> recur(1)을 실행
5. 빈 상자 -> 1을 출력 -> 빈 상자 -> 이전 작업으로 돌아감 -> 이전 작업으로 돌아감
6. 4를 출력 -> recur(2)를 실행 -> recur(1)을 실행
7. 1을 출력 -> 빈 상자 -> 이전 작업으로 돌아감
8. 2를 출력 -> 빈 상자 -> 이전 작업으로 돌아감
9. 모든 작업 종료.
```
이러한 순서로 실행되어서 결과는 1, 2, 3, 1, 4, 1, 2 이 될 것이다.  
이 처럼 가장 위쪽에 위치한 작업부터 시작해 계단식으로 자세히 조사하는 기법을 ***'하향식 분석'*** 이라고 한다.  

### 상향식 분석
상향식 분석은 하향식 분석과 대조적으로 아래쪽부터 쌓아 올리며 분석하는 방법이다.  
처음에 주어지는 n이 반드시 양수라는 가정을 하고 recur(1)을 실행하면 아래와 같이 실행될 것이다.  
```
1. recur(0)을 실행
2. 1을 출력
3. recur(-1)을 실행
```
recur(0)과 recur(-1)은 실행되지 않기 때문에 1을 출력하고 종료된다. 그럼 이제 recur(2)에 대해 생각해보자.  
```
1. recur(1)을 실행
2. 2를 출력
3. recur(0)을 실행
```
recur(1)은 위에서 봤듯이 1을 출력한다. 그 다음 2를 출력하고 recur(0)은 아무것도 하지 않기 때문에 결과적으로 출력되는 결과는 1, 2 이다.  
이런식의 과정을 recur(4)까지 해보면 아래와 같다.  
```
recur(1) : recur(0) | 1 | recur(-1)
recur(2) : recur(1) | 2 | recur(0)
recur(3) : recur(2) | 3 | recur(1)
recur(4) : recur(3) | 4 | recur(2)

recur(0)과 recur(-1)은 아무것도 하지 않는다.
```
이런식으로 아래부터 쌓아올리며 결과를 도출하는 것을 ***'상향식 분석'*** 이라고 한다.  

## 재귀 알고리즘의 비재귀적 표현
위에서 사용한 recur() 예제를 계속 사용해 recur 메서드를 재귀를 사용하지 않고 구현하는 방법을 알아보자.  
### 꼬리 재귀의 제거
메서드의 꼬리에서 재귀 호출하는 메서드 recur(n - 2)는 인자로 n - 2를 전달하여 recur 메서드를 호출한다는 의미이다.  
이 말은 아래과 같다. n의 값을 n - 2로 바꾸고 메서드의 시작지점으로 돌아간다.  
n - 2를 인자로하는 recur를 호출한 것이니까 위처럼 해도 같은 말이 된다.  
그렇다면 recur은 꼬리 재귀를 제거해 아래처럼 쓸 수 있다.
``` java
public static void recur(int n) {
    while (n > 0) {
        recur(n - 1);
        System.out.println(n);
        n = n - 2;
    }
}
```

### 재귀의 제거
꼬리 재귀와는 다르게 앞에서 호출하는 recur(n - 1)은 재귀를 제거하기 쉽지 않다.  
왜냐하면 다음 동작에서 n을 출력하는데 이러면 n = n - 1을 해주고 n을 출력할 때도 문제가 생기고 n = n - 2 에서도 원하는대로 동작하지 않는다.  
그렇다면 아래와 같이 n의 값을 임시로 저장한 후 사용해야한다. 그렇다면 아래와 같은 순서로 만들어야 한다.  
```
1. 현재 n의 값을 임시로 저장한다.
2. n의 값을 n - 1로 변경하고 메서드의 시작지점으로 간다.
3. 임시로 저장했던 n의 값을 꺼내 출력한다.
```
이 때 이러한 부분을 해결해 줄 수 있는 것이 앞서 배운 스택구조 이다.  
스택구조를 이용해서 코드를 짜면 아래와 같다.
```java
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    int n = sc.nextInt();
    IntStack stack = new IntStack(n);

    while(true) {
        if(n > 0) {
            stack.push(n);
            n = n - 1;
            continue;
        }

        if(!stack.isEmpty()) {
            n = stack.pop();
            System.out.println(n);
            n = n - 2;
            continue;
        }

        break;
    }
}
```
위와 같은 동작이 될 것이다. 아래의 그림을 보면서 하나씩 천천히 따라가보자. (n은 4라고 가정한다.)  

<br>

![재귀제거(1)](이미지/재귀제거(1).png) 

<br>

```
1. 위쪽의 if문에서 4 > 0이므로 4를 스택에 push하고 n에 -1을 해주고 continue를 통해 반복문의 맨위로 올라간다.
2. 3 > 0 이므로 역시 똑같은 동작을 한다.
3. 이렇게 n이 0 이하가 될 때까지 반복한다. 
```

<br>

![재귀제거(2)](이미지/재귀제거(2).png) 

<br>

```
4. n이 0이므로 위쪽 if문을 지나 아래쪽 if문을 만나 1을 pop한 후 n에 저장한다.
5. 저장한 n을 출력한다.
6. n에 -2를하고 반복문의 맨 위로 올라간다.
7. n = -1이므로 역시 위쪽 if문을 지나 아래쪽 if문에서 2를 pop하고 같은 동작을 한다.
```

<br>

![재귀제거(3)](이미지/재귀제거(3).png) 

<br>

```
1. 이 전에 3을 pop해서 -2 해줬기 때문에 n = 1이 되어서 위쪽 if문에 다시 걸린다.
2. 1을 push해주고 n에 -1을 해준다.
3. 위쪽 if문을 지나 1을 pop하고 1을 출력한다.
4.  이러한 동작을 위아래 if문에 모두 안걸릴 때까지 반복해주면 break문에 걸려 while문의 동작이 끝나게된다.
```
이렇게하면 재귀를 제거할 수 있다.

## 하노이의 탑
하노이의 탑은 프랑스의 수학자 에두아르 뤼카가 1883년 소개한 유명한 문제로, 3개의 기둥 이 있고 왼쪽 기둥에 쌓여있는 원반의 모양 그대로 중앙 혹은 오른쪽 기둥으로 옮기는 문제이다.

<br>

![히노이의탑](이미지/하노이의탑.png) 

<br>

하노이의 탑에는 `지켜야하는 규칙`이 있다.  
* 모든 원반은 크기가 다르고 처음에는 원반이 규칙에 맞게 첫 번째 기둥에 쌓여있다.
* 원반은 한 번에 한개씩만 옮길 수 있다.
* 큰 원반을 작은 원반 위에 쌓을 수 없다.

<br>

![하노이의탑(2)](이미지/%ED%95%98%EB%85%B8%EC%9D%B4%EC%9D%98%20%ED%83%91(2).jfif)

<br>

위의 그림은 원반이 3개일 때의 모든 과정을 나타낸 것이다.  
하노이의 탑 알고리즘의 핵심은 맨 밑의 원반을 제외한 나머지 원반들이 쌓여있는 모습을 `그룹`이라고 했을 때 그 `그룹`을 중앙 기둥 또는 오른쪽 기둥으로 얼마나 최소한의 횟수로 옮기는지가 중요하다.  


앞서 말했듯이 하노이의 탑 알고리즘은 맨 밑 원반과 나머지 원반묶음인 `그룹`으로 나누어서보면 된다.  
예를 들어 n개의 원반이 있다면 맨밑원반과 n-1개의 그룹으로 볼 수 있고  
그 n-1개의 원반은 다시 n-1개에서의 맨밑원반과 n-2개의 그룹으로 볼 수 있다.  
이런식으로 나누어서 원반묶음의 이동을 `재귀적`으로 볼 수 있다.  

---
우선 재귀함수를 만들기 전에 6-x-y라는 변수에 대해서 알아보자.  
앞서 설명했듯이 기둥은 기둥1(왼쪽 기둥), 기둥2(중앙 기둥), 기둥3(오른쪽 기둥)이 있다.   
어디에서 시작하든 처음 원반이 존재하는 시작 기둥을 `x`라 하고 모든 원반을 옮기려고 하는 목표 기둥을 `y` 남는 기둥을 `z`라 한다면 `6 = x의 기둥번호 + y의 기둥번호 + z의 기둥번호` 이라는 식이 성립된다.  
z는 남는 기둥의 번호라 했으므로 위의 식은 `남는 기둥의 번호 = 6 - x - y`라는 식이 된다.  

<br>

![하노이의탑(3)](이미지/%ED%95%98%EB%85%B8%EC%9D%B4%EC%9D%98%ED%83%91(3).png)

<br>

그림에서 보이듯이 기둥1에서 목표기둥인 기둥2로 옮기려면 맨밑원반을 제외한 `그룹`을 남는 기둥으로 옮겨서 목표 기둥에 맨밑원반이 오도록 해야한다.  
그렇기 때문에 `6 - x - y`로 남은 기둥의 번호를 구하는 것이다.


이제 함수를 만들어보자. 
```java
public static void move(int n, int x, int y) {
    if(n > 1) move(n - 1, x, 6-x-y);

    System.out.println(n + "번 원반 " + x + "에서 " + y + "로 이동");

    if(n > 1) move(n - 1, 6-x-y, y);
}
```

위의 함수의 순서를 설명하면 아래와 같다.
1. `move(n - 1, x, 6-x-y)` 맨밑원반을 제외한 나머지 그룹을 남은 기둥에 옮긴다.  
2. `System.out.println(n + "번 원반 " + x + "에서 " + y + "로 이동")` 맨밑원반을 목표 기둥으로 옮긴다. 
3. `move(n - 1, 6-x-y, y)` 맨밑원반을 제외한 나머지 그룹을 남은 기둥에서 목표 기둥으로 옮긴다.  

n - 1을 파라미터로 넘겨주면서 그룹을 점점 좁혀나가 n = 1이 되었을 때가 재귀의 종료 조건이된다.
                                                                
