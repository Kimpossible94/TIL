# 재귀 알고리즘
## 팩토리얼 구하기
팩토리얼을 재귀를 이용해 구하면서 재귀의 개념에 대해 알아보자.  
음이 아닌 정수n의 팩토리얼(n!)은 아래처럼 재귀적으로 정의할 수 있다.  
```
1. 0! = 1
2. n > 0이면 n! = n * (n - 1)!
```
위의 정의를 그대로 프로그램으로 구현하면 아래와 같다.
```java
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    int n = sc.nextInt();

    factorial(n);
}

public static int factorial(int n) {
    if (n > 0) {
        return n * factorial(n - 1);
    } else {
        return 1;
    }
}
``` 
위 코드에서 n값이 3이라고 가정하면 아래처럼 될 것이다.  
3 * factorial(2) * factorial(1) * factorial(0)  
3 * factorial(2) * factorial(1) * 1  
3 * factorial(2) * 1 * 1  
3 * 2 * 1 * 1 = 6  
  
## 직접 재귀와 간접 재귀
위의 팩토리얼 구하기처럼 자시 자신을 호출하여 작업을 수행하는 방법을 직접 재귀라고 한다.  
간접 재귀는 메서드 a, b가 있을 때 a에서 b를 호출하고 b에서 다시 a를 호출하는 구조를 말한다.  

## 유클리드 호제법
유클리드 호제법은 두개의 양의 정수 혹은 두 다항식의 최대공약수를 구하는 방법을 말한다.  
```
두 양의 정수 a,b(a > b)에 대하여 a = bq + r (0 ≤ r < b)라 하면 a,b의 최대공약수는 b,r의 최대 공약수와 같다.
즉, gcd(a, b) = gcd(b, r)
r = 0이라면 a,b의 최대공약수는 b가 된다.
```
위의 내용이 유클리드 호제법을 정의한 내용이다. 정의를 이해하기 위해 정리해보자.  
1. 두 양의 정수 A,B(A > B)가 있다. 큰 수인 A에서 B를 나눈다면 아래와 같이 표현할 수 있다.  
A = B * Q + R  
R은 A와 B를 나눈 나머지이며 Q는 몫이다.
2. 이때 A와 B의 최대공약수를 Q라고 가정하면 A = a * Q , B = b * Q (a와 b는 서로소)가 성립된다.  
3. 이 것을 위의 R에 대입해 정리하면 아래와 같다.  
R = aG - bGQ = (a - bQ)G  
그리고 아까 위에서 언급한걸 보면  
B = bG  
R과 B 모두 G라는 공통의 약수를 가지고 있다.  
4. 이제 R과 B에 있는 G라는 약수가 최대공약수가 되는지 확인해야한다.  
그래야 A,B의 최대공약수가 B, R의 최대공약수 라는 것이 증명되기 때문이다.  
그러면 (a - bG)와 b가 서로소라는 것을 증명하면 된다. (서로소는 두 수의 최대공약수가 1인 것을 서로소라고 말한다.)  
5. 서로소가 아니다라는 가정으로 접근해보자. 이 가정이 틀렸다면 서로소이기 때문이다.  
두 수가 서로소가 아니라고 가정했으니 1보다 큰 최대공약수(T)가 존재한다는 말이 된다.  
a - bQ = MT , b = NT  
b를 대입하면 a - NTQ = MT 이렇게 된다. 이걸 변형시키면 아래와 같다.  
a = MT + NTQ = T(M + NQ)  정리하면 아래와 같다.  
a = (M + NQ)T  
b = NT  
여기에서 모순이 생긴다 a와 b는 서로소이어야 한다.  
1보다 큰 최대공약수인 T를 약수로 가지고 있으므로 서로소가 아니게 된다.  
그렇다면 애초에 1보다 큰 최대공약수인 T를 가지고있다는 가정이 틀린것이 되므로 a와 b는 서로소라는 것이 증명된다.
6. 이렇게 최대공약수를 구하는 방법이 유클리드 호제법이다.  
바로 최대공약수 계산이 안되는 예를 들어 A = 1980, B = 168이라 했을 때 위의 공식을 이용해  
A = B * Q + R  
1980 = 168 * 11 + 132 (Q는 나눗셈의 몫, R은 나머지)로 나타낼 수 있다.  
그 다음 B인 168과 R인 132의 최대 공약수가 A인 1980과 B인 168과의 최대 공약수와 같다고 했으므로 최대공약수를 구해주면 되는데 아직도 구하기 어렵다.  
그렇다면 다시 공식을 사용하면 된다.  
168 = 132 * 1 + 36 이 된다 이 방식을 계속 진행해보자.  
132 = 36 * 3 + 24  
36 = 24 * 1 + 12  
24 = 12 * 2 + 0  
이렇게 마지막에는 나머지가 0이 된다. 이렇게 나머지가 0이 되었을 때의 다음은 A가 12 B가 0이 될 것이다. 여기서 0은 모든 수의 약수가 아니므로 A인 12가 최종적으로 A와 B의 최대공약수가 된다.  

### 유클리드 호제법 구현
유클리드 호제법에 대해 알아봤으니 이제 이 것을 코드로 만들어보자.  
구현 방법은 간단하다. 정수 a와 b를 입력받고 두 개를 나누고 남은 나머지를 다시 b로 그리고 b를 a로 만들어 나머지가 0이 될때까지 나눗셈을 하면된다.  
```java
public static int gcd(int a, int b) {
    if(b == 0) return a;
    else return gcd(a, b % a);
}

public static void main (String[] args) {
    Scanner sc = new Scanner(System.in);

    int a = sc.nextInt();
    int b = sc.nextInt();

    while (b > a || a == b) {
        a = sc.nextInt();
        b = sc.nextInt();
    }

    int res = gcd(a, b);
}
```
