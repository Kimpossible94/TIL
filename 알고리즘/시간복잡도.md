# 시간복잡도

## 복잡도
### 알고리즘의 성능을 나타내는 척도
여기서 말하는 복잡도는 "코드가 보기에 또는 이해하기에 복잡하다."와는 관련이 없고 **그 함수의 성능과 관련된 복잡도** 이다.

1. 시간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 수행시간을 분석한 것
2. 공간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 메모리 사용량 분석<br>

**시간복잡도**가 높다 -> 수행시간 측면에서 더 많은 시간이 소요될 수 있다. <br>
**시간복잡도**가 낮다 -> 해당 알고리즘이 더 빠르게 실행될 수 있다. <br>
**공간복잡도**가 높다 -> 많은 메모리가 소요될 수 있다. <br>

따라서, 기능이 동일하다면 복잡도가 낮을수록 좋은 알고리즘이라고 분석할 수 있다.

<br>

### 빅오표기법
그렇다면, 이러한 복잡도는 어떻게 표기할까 ?<br>
여러 표기법 중 주로 **빅오 표기법**을 사용한다.<br>

빅오 표기법은 가장 빠르게 증가하는 항만을 고려하는 표기법이다.<br>
가장 빠르게 증가하는 항만을 고려하기 때문에 함수의 상한만을 나타내게 된다.<br>
(빅오 표기법도 엄밀한 정의를 이해하기 위해서는 계산복잡도에 대한 이론을 찾아보아야 한다. 다만, 알고리즘 문제를 푸는 입장에서는 이정도만 기억해도 문제의 요구사항을 분석하는데는 큰 문제가 없다.)<br>

*예시)* 연산 횟수가 $3N^3 + 5N^2 + 1,000,000$ 인 알고리즘이 있다면, 차수가 가장 큰 함수만 남겨서 $O(N^3)$으로 표기한다.<br>
이 때 계수는 무시한다.<br>

빅오표기법의 개념을 극한의 개념으로 생각하면 좀 더 쉽게 생각할 수 있다.<br>
N이 엄청 큰 수(100만, 1억 ...)로 생각하면 $N^3$을 제외한 나머지 수는 $N^3$에 비해 굉장히 작은 수가 되므로 함수의 상한만을 보아도 함수의 성능을 충분히 예측할 수 있다.<br>

![image](https://github.com/Kimpossible94/TIL/assets/80395024/af3c3193-38c0-4564-a013-b2b7daa9b9d4)

위 사진은 대표적인 빅오 표기법으로 복잡도를 나타낸 그래프이다.<br>
알고리즘은 상수 시간 $O(1)$, 로그 시간 $O(logN)$, 선형 시간 $O(N)$, 로그 시간 $O(logN)$, 이차 시간 $O(N^2)$, 삼차 시간 $O(N^3)$, 지수 시간 $O(2^n)$ 등으로 표기법을 붙여 해당 알고리즘을 나타낼 수 있다.<br>
<br>
<img src="https://github.com/Kimpossible94/TIL/assets/80395024/a87d4bc8-e177-491f-b848-b3be50861be3" width="300" height="300">

1. 상수 시간 : 말그래도 상수 번 만큼을 연산을 거치면 수행이 완료되는 것을 말한다.<br>
(= 입력 데이터 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘이다.)<br>

<img src="https://github.com/Kimpossible94/TIL/assets/80395024/0ed36719-c4ee-434e-b4c1-f918727d3b03" width="300" height="300">

2. 선형 시간 : 데이터의 크기가 N이라고 했을 때 N만큼 수행이 된다. <br>
(= n 크기만큼 처리시간이 증가)<br>

<img src="https://github.com/Kimpossible94/TIL/assets/80395024/5b09c2ea-cb90-4fac-b06e-7969d94c0ae8" width="300" height="300">

3. 이차 시간 : 입력 데이터 n만큼 반복하는데, 그 안에서 n만큼 또 반복할 때의 표기 방법이다.<br>

<img src="https://github.com/Kimpossible94/TIL/assets/80395024/fa283b2d-ad2f-4fc1-b2ff-33878fb4d502" width="300" height="300">

4. 로그 시간 : 대표적인 알고리즘은 이진 검색으로 데이터를 한 번 찾을 때마다 반틈씩 없어지는 알고리즘을 O(log n) 이라고 한다.<br>

<br>

### 알고리즘 설계 TIP

2중 반목문이 있다고하면, 시간복잡도가 $O(N^2)$일 것 같지만, 모든 2중 반복문의 시간복잡도가 $O(N^2)$는 아니다.<br>
예를 들어 2중 반복문안에 함수가 있고 그 함수가 오랜시간이 걸린다면 그 함수의 시간복잡도까지 생각을 해야한다.<br>

$O(N^3)$의 알고리즘을 설계한 경우 N의 값이 5000이라면,<br>
1250억이 필요한 연산횟수이고, 파이썬이 1초에 약 5000만번의 계산을 처리할 수 있다고하면 약 2500초 정도가 필요하다.<br>
이런식으로 수행시간을 예측해서 알고리즘을 설계하는 것이 중요하다.<br>

채점용 서버마다 초당 계산할 수 있는 연산횟수가 다르므로 초당 약 2000만번의 연산이 가능하다고 가정하고 문제에 접근하는 것이 좋다.<br>
일반적으로 코딩테스트 문제에서 시간제한은 1 ~ 5초 가량이다.<br>
그래서 문제에서 가장 먼저 확인해야 하는 내용은 시간제한이다.<br>

***알고리즘 문제 해결 과정***<br>
1. 지문 읽기 및 컴퓨터적 사고
2. 요구사항(복잡도) 분석
3. 문제 해결을 위한 아이디어 찾기
4. 소스코드 설계 및 코딩

일반적으로 대부분의 문제 출제자들은 핵심 아이디어를 캐치한다면, 간결하게 소스코드를 작성할 수 있는 형태로 문제를 출제한다.

<br>

### 문제의 시간복잡도 구하기
문제 1  
N 이하의 자연수 중에서 3의 배수이거나 5의 배수인 수를 모두 합한 값을 반환하는 함수func(int n)를 작성하라. n은 10만 이하의 자연수이다. 

func(16) = 60  
func(34567) = 278812814  
func(27639) = 178254968  

```java
    public void func(int n) {
        int sum = 0;
        for (int i = 0; i < n; i++) {
            if(i % 3 == 0 || i % 5 == 0) sum += i;
        }
        System.out.println(sum);
    }
```  
for문에서 i가 3이나 5로 나눠지는지 확인하므로 시간복잡도는 $O(N)$이다.  

문제 2  
주어진 길이 N의 int배열 arr에서 합이 100인 서로 다른 위치의 두 원소가 존재하면 1을, 존재하지 않으면 0을 반환하는 함수 func(int[] arr, int n)을 작성하라.  
arr의 각 수는 0이상 100이하이고 N은 1000이하이다.  

func({1, 52, 48}, 3) = 1  
func({50, 42}, 2) = 0  
func({4, 13, 63, 87}, 4) = 1  

```java
    public int func(int[] arr, int N) {
        for (int i = 0; i < N; i++) {
            for (int j = i+1; j < N; j++) {
                if(arr[i] + arr[j] == 100) return 1;
            }
        }
        return 0;
    }
```
i가 0일때 N-1개의 수에 대해서 100과 비교하고  
i가 1일때 N-2개의 수에 대해서 100과 비교하고  
i가 2일때 N-3개의 수에 대해서 100과 비교하고  
이렇게 반복하면 결국 모든 연산은 $N(N-1)/2$번 일어난다.  
이는 $O(N^2)$인 것을 알 수 있다.

문제 3  
N이 제곱수이면 1을 반환하고 제곱수가 아니라면 0을 반환하는 함수 func(int N)을 작성하라.  
N은 10억 이하의 자연수이다.  

func(9) = 1  
func(693953651) = 0  
func(756580036) = 1  

```java
    public int solution(int N) {
        for (int i = 1; i*i <= N; i++) {
            if(i*i == N) return 1;
        }
        return 0;
    }
```
i가 1,2,3... 이렇게 올라가다가 i*i <= N으로 인해서 i가 $\sqrt{N}$까지 올라가므로 시간복잡도는 $O(\sqrt{N})$이다.  

문제 4   
N이하의 수 중에서 가장 큰 2의 거듭제곱수를 반환하는 함수 func(int N)을 작성하라.  
N은 10억 이하의 자연수이다.  

func(5) = 4  
func(97615282) = 67108864  
func(1024) = 1024  

```java
    public int solution(int N) {
        if(N < 2) return -1;
        int num = 2;
        while(num*2 <= N) num *= 2;
        return num;
    }
```
2, 4, 8, 16.... 이렇게 진행되다가 N보다 커지는 순간 반복문이 멈춘다.  
N이 $2^k$이상 $2^{K+1}$ 미만이라고 할 때 반복문은 최대 k번만 반복된다.  
$log_2(2^k) = k$이므로 시간복잡도는 $O(log N)$이 된다.