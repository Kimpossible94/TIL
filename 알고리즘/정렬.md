# 정렬
## 정렬 알고리즘이란?
정렬은 데이터를 어떤 기준(크기, 사전 순 등)에 따라 일정한 순서로 배열하는 과정을 말함  

## 대표적인 정렬 방식의 종류
* 버블 정렬
* 카운팅 정렬
* 선택 정렬
* 퀵 정렬
* 삽입 정렬
* 병합 정렬

### 버블 정렬
인접한 두 개의 원소를 비교하여 자리를 계속 바꾸는 방식  
교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품모양 같다고 하여 버블 정렬 이라고 함.

한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬됨.  
**버블 정렬의 시간 복잡도는 $O(n^2)$**

#### 버블정렬 오름차순 정렬
```java
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {5, 2, 9, 1, 3};

        bubbleSort(arr);

        for (int n : arr) {
            System.out.print(n + " ");
        }
    }

    private static void bubbleSort(int[] arr) {
        int n = arr.length;
        // 총 배열 크기-1 만큼 반복
        for (int i = 0; i < n-1; i++) {
            // 정렬이 끝난 뒤쪽 부분을 제외하고 비교해야하므로 n-1-i 만큼 반복
            for (int j = 0; j < n-1-i; j++) {
                if(arr[j] > arr[j+1]){
                    // 자리 변경
                    int temp  = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
    }
}
```

### 카운팅 정렬
집합에 각 항목이 몇 개씩 있는지 세어서 정렬하는 방법  
정수나 정수로 표현할 수 있는 자료에 대해서만 적용가능  
카운트들을 위한 공간 할당을 위해서 집합 내의 가장 큰 정수를 알아야함.

#### 카운팅 정렬 오름차순 구현
```java
public class CountingSort {
    public static void main(String[] args) {
        int[] arr = {5, 2, 9, 1, 3};

        countingSort(arr);

        for (int n : arr) {
            System.out.print(n + " ");
        }
    }

    private static void countingSort(int[] arr) {
        int max = findMax(arr); // 집합 중 제일 큰 수 찾기
        int[] countArr = new int[max+1];

        for (int num : arr) countArr[num]++; // 카운팅

        // 정렬
        int idx = 0;
        for (int i = 0; i < countArr.length; i++) {
            while (countArr[i]-- > 0) {
                arr[idx++] = i;
            }
        }
    }

    private static int findMax(int[] arr) {
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if(arr[i] > max) max = arr[i];
        }

        return max;
    }
}
```

### 선택 정렬
배열에서 가장 큰값 또는 가장 작은값을 찾아서 앞에서부터 하나씩 채워나가는 정렬

시간 복잡도는 최선, 최악, 평균 모두 $O(n^2)$  
매 회전마다 남은 배열에서 최소값 또는 최대값을 찾아야하므로 반복문이 2중으로 들어감  

구현이 매우 간단하나 시간복잡도가 높아 비효울적이다.

#### 선택 정렬을 이용한 오름차순 정렬 구현
```java
public class SelectionSort {
    public static void main(String[] args) {
        int[] arr = {5, 2, 9, 1, 3};

        selectionSort(arr);

        for (int n : arr) {
            System.out.print(n + " ");
        }
    }

    private static void selectionSort(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            int minIndex = i;
            
            for (int j = 0; j < arr.length; j++) {
                if(arr[j] < arr[minIndex]) minIndex = j;
            }
            
            int temp = arr[minIndex];
            arr[minIndex] = arr[i]; 
            arr[i] = temp;
        }
    }
}
```