# 1장.  기본 알고리즘

## 알고리즘이란 ?
알고리즘이란 무엇인가에 대해 간단한 프로그램을 통해 알아보자.  
3개의 정숫값 가운데 '최대값'을 구하는 프로그램은 아래와 같다.  
```java
Scanner sc = new Scanner(System.in);

int a = sc.nextInt();
int b = sc.nextInt();
int c = sc.nextInt();

int max = a;
if(b > max) max = b;
if(c > max) max = c;
```
위에서 최대값을 구하는 과정을 아래와 같다.  
1. max에 a값을 넣는다.
2. b 값이 max보다 크면 max에 b 값을 넣는다.
3. c 값이 max보다 크면 max에 c 값을 넣는다.

위의 과정을 그림으로 나타내보자.  
![순서도](이미지/순서도.png)  
이런 그림은 여러 종류가 있으며, 이 그림은 ***순서도***라고 한다.  
  
프로그램의 흐름은 검은 실선을 따라 위에서 아래로 향하고, 그 과정에서 사각형안에 작성한 처리 과정이 실행된다. 그리고 마름모를 지날 때는 그 안에 작성된 '조건'을 평가한 결과에 따라서 Yes, No중 하나를 따라간다.  
  
결과적으로 **알고리즘**은 다음과 같이 정의할 수 있다.
```
문제를 해결하기 위한 것으로, 명확하게 정의되고 순서가 있는 유한 개의 규칙으로 이루어진 집합
```  
알고리즘을 정의하고 변수의 값에 따라 결과가 맞기도하고 틀리기도 한다면 올바른 알고리즘이라 할 수 없다.  
  
<br>
<br>

## 순서도
프로그래밍 단계는 다음과 같이 이루어 진다.
  
문제의 이해 -> 논리의 설계 -> 코딩 -> 번역 -> 테스트 -> 활용
  
이중 순서도는 프로그램 논리 설계 과정에서 쓰인다.  
순서도란 문제 해결에 쓰인 논리를 단계적으로 그림으로 표현한 것을 말한다.  
또한 순서도를 이용하면 명령문들의 관계를 시각적으로 보여줄 수 있다.  

<br>
<br>

## 순서도의 기호
### 1. 데이터
![순서도](이미지/데이터.png)  
데이터(data)의 입력과 출력을 나타낸다.
### 2. 처리
![순서도](이미지/처리.png)  
처리는 여러 종류의 처리 기능을 수행한다.  
ex) 데이터의 값, 자료형, 위치를 바꾸도록 정의한 연산
### 3. 미리 정의한 처리
![순서도](이미지/미리정의한처리.png)  
**미리 정의한 처리**는 서브 루틴 및 모듈 등 다른 곳에서 이미 정의한 하나 이상의 연산 또는 명령어들로 이루어진 처리를 나타낸다.
### 4. 판단
![순서도](이미지/판단.png)  
판단은 하나의 입구와 하나 이상의 선택할 수 있는 출구가 있고 도형안에 정의한 조건을 평가하여  
하나의 출구를 선택하는 판단 기능을 나타낸다.
### 5. 루프 범위
![순서도](이미지/루프범위.png)  
루프 범위는 그림과 같이 두 부분으로 구성되어 루프의 시작과 루프의 종료를 나타낸다.  
루프의 시작과 종료에는 동일한 이름을 사용한다.  
그림과 같이 시작 기호 혹은 종료 기호에는 초기값, 증가값, 종료값을 표기한다.  

그림에 나와있는 두 루프 범위의 차이를 알아보기위해 while문을 떠올려보자.  
while문은 어떤 조건이 성립하는 동안 반복문 안의 내용을 처리한다.  
그러다 조건문의 조건이 true -> false가 된다면 while문을 종료한다.  
이러한 구조를 '***사전 판단 반복 구조***'라 한다.  
  
반면, 오른쪽과 같은 구조는 do-while문을 생각하면 된다.  
do-while문과 같이 우선적인 처리를 진행하고 while문 조건을 보는 것인데 이러한 구조를  
'***사후 판단 반복 구조***' 라고 한다.

### 6. 선
선은 제어의 흐름을 나타낸다. (프로그램의 논리 순서)   
주로 흐름의 방향을 분명히 나타내고자 할 때 화살표를 붙이는데, 순서도를 작성할 때도 보기 쉽게 화살표를 붙이기도 한다.

### 7. 단말
![순서도](이미지/단말.png)  
단말은 회부 환경으로 나가거나 외부환경으로 들어오는 것을 나타낸다.


<br>
<br>

## 구조적 프로그래밍
하나의 입구와 하나의 출구를 가진 구성 요소만을 계층적으로 배치하여 프로그램을 구성하는 방법을 '구조적 프로그래밍'이라고 합니다. 구조적 프로그래밍은 순차, 선택, 반복이라는 3종류의 제어 흐름을 사용한다.  

<br>
<br>
<br>

# 기본 자료구조

- 자료구조란 ?   
  데이터 단위와 데이터 자체 사이의 물리적 또는 논리적인 관계  
  - 데이터 단위 : 데이터를 구성하는 한 덩어리
  - 자료구조 : 자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법

<br>
<br>
<br>  

# 배열
## 배열의 최댓값 구하기
  
배열 a의 요소가 최대 3개일 때 세 요소중 최댓값은 아래처럼 구할 수 있다.
```java
max = a[0];
if(a[1] > max) max = a[1];
if(a[2] > max) max = a[2];
```
만약 배열의 요소가 많다면 아래처럼 반복문을 사용해 구할 수 있다.
```java
max = a[0];
for(i = 1; i < a.length - 1; i++){
    if(a[i] > max) max = a[i];
}
```  
  
위에서 작성한 알고리즘에 따라 배열 a의 요소에서 최댓값을 구하는 과정은  
a[i]브타 마지막 요소인 a[a.length-1]까지 차례로 살펴본다.  
이처럼 배열의 요소를 하나씩 차례로 살펴보는 과정을 알고리즘 용어로 '***주사***'라고 한다.  
  
## 배열의 요소 역순으로 정렬
{22, 57, 11, 32, 91, 68, 70}인 배열 a가 있다고 하면 요소의 개수는 7이고 역순은 {70, 68, 91, 32, 11, 57, 22}이다.  
이 과정을 그림으로 보면  
![순서도](이미지/배열역정리.png)  
이러한 과정을 거친다.  
교환 횟수는 요소개수/2이며, 이 나눗셈에서 나머지는 버린다.  
그림에서 보이듯이 요소 개수가 홀수인 경우 가운데 요소는 교환할 필요가 없기 떄문이다.  
  
그럼 이것을 반복문을 통해 나타낸다면 아래와 같다.
```java
// n은 배열의 요소 개수를 가르킴(임의의 숫자)
for(int i = 0; i < n/2; i++){
  //배열의 요소를 담아둘 num 변수 생성
  int num = a[i];
  a[i] = a[n-i-1];
  a[n-i-1] = num;
}
```
  
## 기수 변환
정수값을 임의의 기수로 변환하는 알고리즘을 살펴보자.  
- 기수 : 수를 나타내는데 기초가 되는 수  

10진수를 n진수로 변환하려면 정수를 n으로 나눈 나머지를 구하는 동시에 그 몫이 0이 될 때까지 나눗셈을 반복해야한다.  
  
1. 59를 2진수로 변환한다면 아래와 같다.  
    ```
    59 / 2 = 29 ・・・ 1
    29 / 2 = 14 ・・・ 1
    14 / 2 = 7 ・・・ 0
    7 / 2 = 3 ・・・ 1
    3 / 2 = 1 ・・・ 1
    1 / 2 = 0 ・・・ 1
    ```
    (59)<sub>10</sub> = (111011)<sub>2</sub>
  <br>

2. 59를 8진수로 변환하면 아래와 같다.
    ```
    59 / 8 = 7 ・・・ 3
    7 / 8 = 0 ・・・ 7
    ```
    (59)<sub>10</sub> = (73)<sub>8</sub>
<br>

3. 59를 16진수로 변환하면 아래와 같다.
    ```
    59 / 16 = 3 ・・・ B
    3 / 16 = 0 ・・・ 3
    ```
    (59)<sub>10</sub> = (3B)<sub>16</sub>

   * 참고로 16진수는 아래와 같이 표현된다.  
     ```
     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F
     ```

위의 과정을 생각하면서 임의의 양의 정수 n을 2 ~ 36 진수로 기수 변환하는 프로그램을 만들면 아래와 같다.  
```java
public class RadixConversion {
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);

    // 양의 정수 입력
    int positiveInt;
    do {
      positiveInt = sc.nextInt();
    } while (positiveInt < 0)

    // 2 ~ 36 사이의 원하는 기수 입력
    int targetRadix = getTargetRadix();
    do {
      targetRadix = sc.nextInt();
    } while (targetRadix < 2 || targetRadix > 36);

    // 기수 변환이 담길 배열 생성
    char[] radixArr = new char[32];
    // 자리수
    int digits = convertRadix(positiveInt, targetRadix, radixArr);

    for (int i = digits - 1; i >= 0; int--;) {
      Syetem.out.print(radixArr[i]);
    }
  }

  // 정수를 기수 변환하고 자리수를 반환
  private int convertRadix(int positiveInt, int targetRadix, char[] radixArr) {
    int digits = 0;
    String dchar = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    // positiveInt(입력한 정수)가 0이 될 때까지 자릿수를 증가시키며 나눗셈을 진행해 radixArr에 나눗셈의 나머지를 넣어준다.
    do {
      radixArr[digits++] = dchar.charAt(positiveInt % targetRadix);
      targetRadix /= targetRadix;
    } while (positiveInt != 0)

    // 자릿수 반환
    return digits;
  }
}
```  

<br>
<br>

## 소수의 나열
소수 : 1과 자기자신 이외의 어떤 정수로도 나누어 떨어지지 않는 수를 말한다.  
즉, 어떤 정수 n에 대하여 아래와 같은 조건을 만족한다.  
```
2부터 n-1까지의 어떤 정수로 나누어도 나누어 떨어지지 않는다.
```
만약 나누어 떨어지는 수가 존재한다면 그 수는 소수가 아니라 합성수이다.  
<br>
아래는 100이하의 소수를 나열하는 프로그램이다.
```java
public static void main(String args[]) {
  int maxNum = 100;
  for (i = 2; i <= maxNum; i++) {
    if(checkPrime(i)) System.out.println(i);
  }
}

private boolean checkPrime(int num) {
  // 1은 소수가 아니므로 false
  if(num == 1) return false;

  // i가 num과 같아지기 전에 나누어 떨어진다면 소수가 아님
  for (i = 2; i < num; i++){
    if(num / i == 0) return false;
  }

  return true;
}
```

<br>

## 소수 찾기 알고리즘의 개선(1)
위 방법이 아주 기본적인 소수 찾기 알고리즘이다.하지만 위의 방법은 maxNum이 증가할수록 프로그램의 수행시간이 상당히 길어지게 된다.  
그래서 다음으로는 제곱근을 이용하는 방법을 보자.  
  
maxNum을 숫자 A와 B의 합성수(maxNum = A * B)라 하면 아래와 같은 조건이 성립한다.
```
1 ≤ A, B < maxNum
```
여기서 만약 A와 B 둘 다 maxNum의 제곱근보다 크다고 가정해보자. 그럼 아래와 같은 식이 성립할 것이다.  
```
A * B > maxNum
```
maxNum은 A와 B의 합성수이므로 위의 조건은 성립할 수 없다. 따라서 A와 B 둘 중 하나는 반드시 maxNum의 제곱근보다 작아야 한다.  
<br>
예를 들어 maxNum이 23이라고하면, maxNum의 제곱근은 약 4.8이다.
A와 B 둘 다 제곱근보다 큰 정수라고하면 최소값이 5이기 때문에
```
5 * 5 = 25
``` 
위처럼 되므로 합성수가 되지 않는다.  
그리고 여기서 하나 더 속성을 설명하면 maxNum이  A와 B의 합성수라하면 A와 B는 제곱근을 기준으로 대칭성을 가진다. 이 말이 무슨말인지 아래의 예시를 보자.
![순서도](이미지/소수대칭성.png) 
20의 합성수는 그림처럼 대칭성을 가진다. 자세히 보면 대칭을 이루기 때문에 A 또는 B가 20의 제곱근 (약 4.5)이하의 정수이다.  
즉, 20은 4.5이하 정수들의 배수라고 할 수 있다. 그렇기 때문에 maxNum의 제곱근 이하 정수만 검사를 해도 소수를 찾을 수 있는 것이다.
제곱근 이하의 정수에서 0으로 나누어 떨어지는 것이 있다면 소수가 아니라는 뜻이다.  
그럼 아래와 같이 프로그램을 만들 수 있다.
```java
public static void main(String args[]) {
  int maxNum = 100;
  for (i = 2; i <= maxNum; i++) {
    if(checkPrime(i)) System.out.println(i);
  }
}

private boolean checkPrime(int num) {
  // 1은 소수가 아니므로 false
  if(num == 1) return false;

  // i가 num과 같아지기 전에 나누어 떨어진다면 소수가 아님
  for (i = 2; i < Math.sqrt(num); i++){
    if(num / i == 0) return false;
  }

  return true;
}
```

<br>

## 소수 찾기 알고리즘의 개선(2)
다음은 가장 대표적인 방법인 에라토스테네스의 체이다.  
원리는 매우 간단하다. 체를 거르듯이 배수로 소수가 아닌 것들을 거르면 된다.  
예를 들어보자.
```
1~100까지의 수 중에 소수를 구한다고 해보자.  
1은 소수가 아니므로 제외하고 나머지 2 ~ 100까지의 수를 모두 소수라고 일단 가정하고, 2부터 해당 숫자의 배수는 모두 소수목록에서 제외시키는 방법이다.  
  
예를 들어 2의 배수는 2,4,6,8,10...100 이다. 이 안에 들어있는 숫자중 자기자신을 제외한 숫자들을 소수목록에서 제외한다.  
그리고 3으로 넘어가 3의 배수인 3,6,9,12...99 이 안에 들어있는 숫자도 자기자신을 제외한 숫자들을 소수 목록에서 제외한다.
그 다음 4인데 4는 2의 배수에서 소수목록에서 제외됬으므로 건너뛰고  
5로 넘어가 5의 배수인 5,10,15,20,25...100 이 안에서도 마찬가지로 자기자신을 제외한 모든 숫자를 소수 목록에서 제외한다.  
이런식으로 숫자들을 제외시켜 남은 숫자를 소수로 하는 것이다.
```
이 방법도 마찬가지로 제곱근을 사용해 100의 소수를 구한다면 100의 제곱근은 10까지만 검사를 해도 된다.

<br>
<br>

# 2차원 배열
## 한 해의 경과 일 수를 계산하는 프로그램
2차원 배열을 활용해 어떤 날짜의 그 해의 경과 일 수를 계산하는 프로그램을 만들어보자.
  
일반적으로 m월 d일의 그 해 경과 일 수 는 다음과 같다.
```
(m - 1)월의 일 수의 합 + d
```
하지만 2월의 일 수는 윤년이라는 것이 있어서 평년에는 28일, 윤년에는 29일로 해에 따라서 달라진다.  
* 윤년  
```
지구가 태양을 도는 일 수는 정확히 365일이 아니다. 그것을 조정하기 위해 4로 나누어 떨어지는 해를 윤년으로 지정하여 1년을 366일로 한다.  
하지만 이도 정확하지 않으므로 4년으로 나누어 떨어지는 윤년중 100으로 나누어 떨어지거나 400으로 나누어 떨어지지 않는 해는 평년으로 지정했다.
```

그럼 그 해의 경과 일수를 구하는 프로그램은 아래와 같이 만들 수 있다.  
```java
public void static main (String[] args) {
  Scanner sc = new Scanner(System.in);
  int year = sc.nextInt();
  int month = sc.nextInt();
  int day = sc.nextInt();

  int elapseDay = dayOfYear(year, month, day);

  System.out.pringln(elapseDay);
}

private int dayOfYear(int year, int month, int day) {
  int elapseDay = day;

  int[][] daysOfMonth = {
    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, // 평년
    {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} // 윤년
  }

  // 윤년이면 1, 평년이면 0
  int isLeapYear = calLeapYear(year);

  for (int i = 0; i < month; i++) {
    elapseDay += daysOfMonth[isLeapYear][i];
  }

  return elapseDay;
}

private int calLeapYear(int year) {
  // 4로 나누어서 떨어지고 100으로 나누거나 400으로 나누어서 떨어지지 않을 때 윤년이다.
  return (year % 4 == 0 && year % 100 != 0 || year % 400 != 0) ? 1 : 0;
}
