# 시간복잡도

## 복잡도
### 알고리즘의 성능을 나타내는 척도
여기서 말하는 복잡도는 "코드가 보기에 또는 이해하기에 복잡하다."와는 관련이 없고 **그 함수의 성능과 관련된 복잡도** 이다.

1. 시간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 수행시간을 분석한 것
2. 공간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 메모리 사용량 분석<br>

**시간복잡도**가 높다 -> 수행시간 측면에서 더 많은 시간이 소요될 수 있다. <br>
**시간복잡도**가 낮다 -> 해당 알고리즘이 더 빠르게 실행될 수 있다. <br>
**공간복잡도**가 높다 -> 많은 메모리가 소요될 수 있다. <br>

따라서, 기능이 동일하다면 복잡도가 낮을수록 좋은 알고리즘이라고 분석할 수 있다.

<br>

### 빅오표기법
그렇다면, 이러한 복잡도는 어떻게 표기할까 ?<br>
여러 표기법 중 주로 **빅오 표기법**을 사용한다.<br>

빅오 표기법은 가장 빠르게 증가하는 항만을 고려하는 표기법이다.<br>
가장 빠르게 증가하는 항만을 고려하기 때문에 함수의 상한만을 나타내게 된다.<br>
(빅오 표기법도 엄밀한 정의를 이해하기 위해서는 계산복잡도에 대한 이론을 찾아보아야 한다. 다만, 알고리즘 문제를 푸는 입장에서는 이정도만 기억해도 문제의 요구사항을 분석하는데는 큰 문제가 없다.)<br>

*예시)* 연산 횟수가 $3N^3 + 5N^2 + 1,000,000$ 인 알고리즘이 있다면, 차수가 가장 큰 함수만 남겨서 $O(N^3)$으로 표기한다.<br>
이 때 계수는 무시한다.<br>

빅오표기법의 개념을 극한의 개념으로 생각하면 좀 더 쉽게 생각할 수 있다.<br>
N이 엄청 큰 수(100만, 1억 ...)로 생각하면 $N^3$을 제외한 나머지 수는 $N^3$에 비해 굉장히 작은 수가 되므로 함수의 상한만을 보아도 함수의 성능을 충분히 예측할 수 있다.<br>

![image](https://github.com/Kimpossible94/TIL/assets/80395024/af3c3193-38c0-4564-a013-b2b7daa9b9d4)

위 사진은 대표적인 빅오 표기법으로 복잡도를 나타낸 그래프이다.<br>
알고리즘은 상수 시간 $O(1)$, 로그 시간 $O(logN)$, 선형 시간 $O(N)$, 로그 시간 $O(logN)$, 이차 시간 $O(N^2)$, 삼차 시간 $O(N^3)$, 지수 시간 $O(2^n)$ 등으로 표기법을 붙여 해당 알고리즘을 나타낼 수 있다.<br>
<br>
<img src="https://github.com/Kimpossible94/TIL/assets/80395024/a87d4bc8-e177-491f-b848-b3be50861be3" width="300" height="300">

1. 상수 시간 : 말그래도 상수 번 만큼을 연산을 거치면 수행이 완료되는 것을 말한다.<br>
(= 입력 데이터 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘이다.)<br>

<img src="https://github.com/Kimpossible94/TIL/assets/80395024/0ed36719-c4ee-434e-b4c1-f918727d3b03" width="300" height="300">

2. 선형 시간 : 데이터의 크기가 N이라고 했을 때 N만큼 수행이 된다. <br>
(= n 크기만큼 처리시간이 증가)<br>

<img src="https://github.com/Kimpossible94/TIL/assets/80395024/5b09c2ea-cb90-4fac-b06e-7969d94c0ae8" width="300" height="300">

3. 이차 시간 : 입력 데이터 n만큼 반복하는데, 그 안에서 n만큼 또 반복할 때의 표기 방법이다.<br>

<img src="https://github.com/Kimpossible94/TIL/assets/80395024/fa283b2d-ad2f-4fc1-b2ff-33878fb4d502" width="300" height="300">

4. 로그 시간 : 대표적인 알고리즘은 이진 검색으로 데이터를 한 번 찾을 때마다 반틈씩 없어지는 알고리즘을 O(log n) 이라고 한다.<br>

<br>

### 알고리즘 설계 TIP

2중 반목문이 있다고하면, 시간복잡도가 $O(N^2)$일 것 같지만, 모든 2중 반복문의 시간복잡도가 $O(N^2)$는 아니다.<br>
예를 들어 2중 반복문안에 함수가 있고 그 함수가 오랜시간이 걸린다면 그 함수의 시간복잡도까지 생각을 해야한다.<br>

$O(N^3)$의 알고리즘을 설계한 경우 N의 값이 5000이라면,<br>
1250억이 필요한 연산횟수이고, 파이썬이 1초에 약 5000만번의 계산을 처리할 수 있다고하면 약 2500초 정도가 필요하다.<br>
이런식으로 수행시간을 예측해서 알고리즘을 설계하는 것이 중요하다.<br>

채점용 서버마다 초당 계산할 수 있는 연산횟수가 다르므로 초당 약 2000만번의 연산이 가능하다고 가정하고 문제에 접근하는 것이 좋다.<br>
일반적으로 코딩테스트 문제에서 시간제한은 1 ~ 5초 가량이다.<br>
그래서 문제에서 가장 먼저 확인해야 하는 내용은 시간제한이다.<br>

***알고리즘 문제 해결 과정***<br>
1. 지문 읽기 및 컴퓨터적 사고
2. 요구사항(복잡도) 분석
3. 문제 해결을 위한 아이디어 찾기
4. 소스코드 설계 및 코딩

일반적으로 대부분의 문제 출제자들은 핵심 아이디어를 캐치한다면, 간결하게 소스코드를 작성할 수 있는 형태로 문제를 출제한다.
