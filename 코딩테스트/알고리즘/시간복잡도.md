# 시간복잡도

## 복잡도
### 알고리즘의 성능을 나타내는 척도
코드의 복잡도와는 다르다 코드가 보기에 또는 이해하기에 복잡하다는 아니고 그 함수의 성능과 관련된 복잡도 이다.
따라서, 시간복잡도가 높다 -> 수행시간 측면에서 더 많은 시간이 소요될 수 있다.
시간복잡도가 낮다. -> 해당 알고리즘이 더 빠르게 실행될 수 있다는 말

공간복잡도가 높다 -> 많은 메모리가 소요될 수 있다.

따라서, 기능이 동일하다면 복잡도가 낮을수록 좋은 알고리즘이라고 분석할 수 있다.

시간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 수행시간을 분석한 것
공간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 메모리 사용량 분석

그렇다면, 이러한 복잡도는 어떻게 표기할까
빅오 표기법 : 가장 빠르게 증가하는 항만을 고려하는 표기법이다.
가장 빠르게 증가하는 항만을 고려하기 때문에 함수의 상한만을 나타내게 된다.
(빅오 표기법도 엄밀한 정의를 이해하기 위해서는 계산복잡도에 대한 이론을 찾아보아야 한다. 다만, 알고리즘 문제를 푸는 입장에서는 이정도만 기억해도 문제의 요구사항을 분석하는데는 큰 문제가 없다.)
예 ) 연산 횟수가 3N^3 + 5N^2 + 1,000,000 인 알고리즘이 있다면, 빅오표기법으로 나타낼 때 차수가 가장 큰 함수만 남겨서
O(N^3)으로 표기한다. 이 때 계수는 무시한다.

빅오표기법의 개념을 극한의 개념으로 생각하면 좀 더 쉽게 생각할 수 있다.
N이 엄청 큰 수(100만, 1억 ...)로 생각하면 N^3을 제외한 나머지 수는 N^3에 비해 굉장히 작은 수가 되므로 함수의 상한만을 보아도 함수의 성능을 충분히 예측할 수 있다.

실제로 알고리즘은 상수 시간 O(1), 로그 시간 O(logN), 선형 시간 O(N), 로그 선형 시간 O(NlogN), 이차 시간 O(N^2), 삼차 시간 O(N^3), 지수 시간 O(2^n) 등으로 표기법을 붙여 해당 알고리즘을 나타낼 수 있다.
상수 시간 : 말그래도 상수 번 만큼을 연산을 거치면 수행이 완료되는 것을 말한다.
로그 시간 : logN에 비례하는 만큼 수행이 된다.
선형 시간 : 데이터의 크기가 N이라고 했을 때 N만큼 수행이 된다.

시간 복잡도 계산 예시 
[N개의 데이터의 합을 계산하는 프로그램]
array  = [3, 5, 1, 2, 4]
summary = 0

for x in array:
  sumary += x

printI(summary)
이 상황에서 시간복잡도는 데이터의 개수인 N에 비례하므로
O(N)이다.

[2중 반복문을 이용하는 프로그램]
array = [3, 5, 1, 2, 4,]

for i in array:
  for j in array:
    temp = i * j
    print(temp)

여기서의 시간복잡도는 데이터를 순회하면서 다시 데이터를 순회하므로 시간복잡도는 O(N^2)에 비례한다.
하지만, 모든 2중 반복문의 시간복잡도가 O(N^2)는 아니다.
예를 들어 2중 반복문안에 함수가 있고 그 함수가 오랜시간이 걸린다면 그 함수의 시간복잡도까지 생각을 해야한다.

알고리즘 설계 Tip
O(N^3)의 알고리즘을 설계한 경우 N의 값이 5000이라면 
1250억이 필요한 연산횟수이고, 파이썬이 1초에 약 5000만번의 계산을 처리할 수 있다고하면 약 2500초 정도가 필요하다.
이런식으로 수행시간을 예측해서 알고리즘을 설계하는 것이 중요하다.
채점용 서버마다 초당 계산할 수 있는 연산횟수가 다르므로
초당 약 2000만번의 연산이 가능하다고 가정하고 문제에 접근하는 것이 좋다.
일반적으로 코딩테스트 문제에서 시간제한은 1 ~ 5초 가량이다.
그래서 문제에서 가장 먼저 확인해야 하는 내용은 시간제한이다.

알고리즘 문제 해결 과정
1. 지문 읽기 및 컴퓨터적 사고
2. 요구사항(복잡도) 분석
3. 문제 해결을 위한 아이디어 찾기
4. 소스코드 설계 및 코딩
일반적으로 대부분의 문제 출제자들은 핵심 아이디어를 캐치한다면, 간결하게 소스코드를 작성할 수 있는 형태로 문제를 출제한다.
