# 정렬 알고리즘
정렬부터 공부하는 이유는 정렬 알고리즘의 효율성 때문이다.<br>
따라서, 몇 가지 정렬 알고리즘을 알아본 후 시간 복잡도의 개념에 대해 단계적으로 알아보자.

## 선택 정렬

> 다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.<br>
> 1 10 5 8 7 6 4 3 2 9

위와 같은 문제를 보았을 때 가장 직관적인 접근 방법은 바로 "**선택 정렬**"이다.<br>
선택 정렬의 가장 핵심 아이디어는 "**가장 작은 것을 선택해서 제일 앞으로 보낸다.**"이다

**선택 정렬의 순서 따라가보기**<br>
> 숫자들 중 가장 작은 숫자를 찾는다. => 1을 찾음 <br>
> 가장 작은 숫자를 제일 왼쪽에 위치 시킨다. => 1 10 5 8 7 6 4 3 2 9 <br>
> <br>
> 1번째 숫자를 제외한 나머지 숫자 중 제일 작은 숫자를 찾는다 => 2를 찾음 <br>
> 2를 1번째 숫자 오른쪽에 위치 시킨다 => 1 2 10 5 8 7 6 4 3 2 9<br>
> <br>
> 위 과정을 반복하면 결과적으로 1 2 3 4 5 6 7 8 9 10 이런식으로 정렬이 된다.<br>

**코드로 표현하면 아래와 같다.** <br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/ba01d5f3-fe0a-47c9-8727-4ba11542775d) <br>

**그럼 이 선택정렬은 얼마나 많은 시간을 잡아먹는지 생각해보자.**
> 처음에는 전부 다 살펴보므로 10번을 탐색한다. <br>
> 두번째에는 제일 왼쪽을 제외한 나머지인 9번을 탐색한다. <br>
> 그렇게 하면 총 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 번을 탐색하게 된다. <br>
> 식을 보면 등차수열로 첫째항이 $a$이고 $n$항의 값이 $l$일 때 등차수열의 합($S_n$)공식은 $S_n = n(a+l)/2$이다. <br>
> 따라서, $10(1+10)/2$이므로 55번 반복된다. <br>
> 탐색의 횟수는 공차가 1, 첫번째 항인 N인 등차수열 이므로 아래과 같이 나타낼 수 있다. <br>
> <br>
> $N(N+1)/2$ <br>
> <br>
> 일반적으로 컴퓨터 프로그래밍에서는 N이 굉장히 크다는 가정하에 나누거나 더하는 연산은 큰 의미가 없기때문에 무시를 한다. <br>
> 그래서 수행시간이 $N * N$ 이라고 표기를 한다.  <br>
> 빅오표기법으로 $O(N^2)$이다. <br>
>> 결과적으로 선택 정렬의 시간 복잡도는 $O(N^2)$이다. <br>

**$O(N^2)$은 정렬 알고리즘 중 굉장히 느리고 비효울적인 알고리즘이다.** <br>
<br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/c36ecd71-cd6a-46ec-b4a6-ce32b815b035) <br>
<br>
> x축(데이터의 개수)가 조금만 커져도 y축(연산횟수)이 엄청나게 증가한다는 특징이 있다. <br>

