# 정렬 알고리즘
정렬부터 공부하는 이유는 정렬 알고리즘의 효율성 때문이다.<br>
따라서, 몇 가지 정렬 알고리즘을 알아본 후 시간 복잡도의 개념에 대해 단계적으로 알아보자.

## 선택 정렬

> 다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.<br>
> 1 10 5 8 7 6 4 3 2 9

위와 같은 문제를 보았을 때 가장 직관적인 접근 방법은 바로 "**선택 정렬**"이다.<br>
선택 정렬의 가장 핵심 아이디어는 "**가장 작은 것을 선택해서 제일 앞으로 보낸다.**"이다

**선택 정렬의 순서 따라가보기**<br>
> 숫자들 중 가장 작은 숫자를 찾는다. => 1을 찾음 <br>
> 가장 작은 숫자를 제일 왼쪽에 위치 시킨다. => 1 10 5 8 7 6 4 3 2 9 <br>
> <br>
> 1번째 숫자를 제외한 나머지 숫자 중 제일 작은 숫자를 찾는다 => 2를 찾음 <br>
> 2를 1번째 숫자 오른쪽에 위치 시킨다 => 1 2 10 5 8 7 6 4 3 2 9<br>
> <br>
> 위 과정을 반복하면 결과적으로 1 2 3 4 5 6 7 8 9 10 이런식으로 정렬이 된다.<br>

**코드로 표현하면 아래와 같다.** <br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/ba01d5f3-fe0a-47c9-8727-4ba11542775d) <br>

**그럼 이 선택정렬은 얼마나 많은 시간을 잡아먹는지 생각해보자.**
> 처음에는 전부 다 살펴보므로 10번을 탐색한다. <br>
> 두번째에는 제일 왼쪽을 제외한 나머지인 9번을 탐색한다. <br>
> 그렇게 하면 총 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 번을 탐색하게 된다. <br>
> 식을 보면 등차수열로 첫째항이 $a$이고 $n$항의 값이 $l$일 때 등차수열의 합($S_n$)공식은 $S_n = n(a+l)/2$이다. <br>
> 따라서, $10(1+10)/2$이므로 55번 반복된다. <br>
> 탐색의 횟수는 공차가 1, 첫번째 항이 N, N번째 항이 1인 등차수열 이므로 아래과 같이 나타낼 수 있다. <br>
> <br>
> $N(N+1)/2$ <br>
> <br>
> 일반적으로 컴퓨터 프로그래밍에서는 N이 굉장히 크다는 가정하에 나누거나 더하는 연산은 큰 의미가 없기때문에 무시를 한다. <br>
> 그래서 수행시간이 $N * N$ 이라고 표기를 한다.  <br>
> 빅오표기법으로 $O(N^2)$이다. <br>
>> 결과적으로 선택 정렬의 시간 복잡도는 $O(N^2)$이다. <br>

**$O(N^2)$은 정렬 알고리즘 중 굉장히 느리고 비효울적인 알고리즘이다.** <br>
<br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/c36ecd71-cd6a-46ec-b4a6-ce32b815b035) <br>
<br>
> x축(데이터의 개수)가 조금만 커져도 y축(연산횟수)이 엄청나게 증가한다는 특징이 있다. <br>

## 버블정렬

버블정렬의 가장 핵심 아이디어는 "**옆에 있는 값과 비교해서 더 작은 값을 앞으로 보낸다.**"이다.

**버블정렬의 순서 따라가보기**<br>
> 1 10 5 8 7 6 4 3 2 9 <br>
> 1과 10을 비교 후 작은 것을 앞으로 옮긴다. <br>
> 1 10 5 8 7 6 4 3 2 9 <br>
> 10과 5를 비교 후 작은 것을 앞으로 옮긴다. <br>
> 1 5 10 8 7 6 4 3 2 9 <br>
> 이 과정을 반복하면 가장 큰 수인 10이 맨뒤로 이동한다. <br>
> 1 5 8 7 6 4 3 2 9 10 <br>
> 그럼 이제 제일 큰 수인 10이 맨뒤에 있으므로 맨뒤를 제외하고 똑같은 과정을 반복한다. <br>

**코드로 표현하면 아래와 같다.** <br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/83e97abb-7df3-42f7-9958-3ba2399ef5cd)<br>

**그럼 버블정렬의 시간복잡도를 알아보자.**
> 선택 정렬과 마찬가지로 한 번 반복을 할 때마다 반복횟수가 하나씩 줄어든다.<br>
> 총 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 번을 탐색하게 된다. <br>
> 선택 정렬과 마찬가지로 탐색의 횟수는 공차가 1, 첫번째 항이 N, N번째 항이 1인 등차수열 이므로 아래과 같이 나타낼 수 있다. <br>
> <br>
> $N(N+1)/2$ <br>
> <br>
>> 결과적으로 버블정렬의 시간 복잡도는 $O(N^2)$이다. <br>

**선택 정렬과의 비교**<br>
***1. 선택 정렬***<br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/81815b9b-0149-4c64-9dfa-b76320987921)<br>
***2. 버블 정렬***<br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/9259d495-c672-4010-b360-b1466200058e)<br>
> 선택 정렬은 한차례 전체적으로 비교 후 마지막에 값의 위치를 바꿔준다. <br>
> 하지만 버블 정렬은 비교를 하면서 동시에 값들의 위치를 서로 바꿔주기 때문에 <br>
> 같은 복잡도를 가졌지만 실제 수행시간은 버블 정렬이 좀 더 느리다. <br>

