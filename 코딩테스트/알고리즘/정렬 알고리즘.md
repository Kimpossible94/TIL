# 정렬 알고리즘
정렬부터 공부하는 이유는 정렬 알고리즘의 효율성 때문이다.<br>
따라서, 몇 가지 정렬 알고리즘을 알아본 후 시간 복잡도의 개념에 대해 단계적으로 알아보자.

## 선택 정렬
```
다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.
1 10 5 8 7 6 4 3 2 9
```
위와 같은 문제를 보았을 때 가장 직관적인 접근 방법은 바로 "**선택 정렬**"이다.<br>
선택 정렬의 가장 핵심 아이디어는 "**가장 작은 것을 선택해서 제일 앞으로 보낸다.**"이다

**선택 정렬의 순서 따라 가보기**<br>
> 숫자 중 가장 작은 숫자를 찾는다. => 1을 찾음 <br>
> 가장 작은 숫자를 제일 왼쪽에 위치시킨다. => 1 10 5 8 7 6 4 3 2 9 <br>
> <br>
> 1번째 숫자를 제외한 나머지 숫자 중 제일 작은 숫자를 찾는다 => 2를 찾음 <br>
> 2를 1번째 숫자 오른쪽에 위치시킨다 => 1 2 10 5 8 7 6 4 3 2 9<br>
> <br>
> 위 과정을 반복하면 결과적으로 1 2 3 4 5 6 7 8 9 10 이런 식으로 정렬된다.<br>

**코드로 표현하면 아래와 같다.** <br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/ba01d5f3-fe0a-47c9-8727-4ba11542775d) <br>

**그럼 이 선택 정렬은 얼마나 많은 시간을 잡아먹는지 생각해보자.**
> 처음에는 전부 다 살펴보므로 10번을 탐색한다. <br>
> 두 번째에는 제일 왼쪽을 제외한 나머지인 9번을 탐색한다. <br>
> 그렇게 하면 총 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1번을 탐색하게 된다. <br>
> 식을 보면 등차수열로 첫째항이 $a$이고 $n$항의 값이 $l$일 때 등차수열의 합($S_n$)공식은 $S_n = n(a+l)/2$이다. <br>
> 따라서, $10(1+10)/2$이므로 55번 반복된다. <br>
> 탐색의 횟수는 공차가 1, 첫 번째 항이 N, N 번째 항이 1인 등차수열이므로 아래와 같이 나타낼 수 있다. <br>
> <br>
> $N(N+1)/2$ <br>
> <br>
> 일반적으로 컴퓨터 프로그래밍에서는 N이 굉장히 크다는 가정하에 나누거나 더하는 연산은 큰 의미가 없으므로 무시를 한다. <br>
> 그래서 수행시간이 $N * N$ 이라고 표기를 한다.  <br>
> 빅오표기법으로 $O(N^2)$이다. <br>
>> 결과적으로 선택 정렬의 시간 복잡도는 $O(N^2)$이다. <br>

**$O(N^2)$은 정렬 알고리즘 중 굉장히 느리고 비효율적인 알고리즘이다.** <br>
<br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/c36ecd71-cd6a-46ec-b4a6-ce32b815b035) <br>
<br>
> x축(데이터의 개수)가 조금만 커져도 y축(연산횟수)이 엄청나게 증가한다는 특징이 있다. <br>

<br>
<br>

## 버블 정렬
```
다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.
1 10 5 8 7 6 4 3 2 9
```
버블 정렬의 가장 핵심 아이디어는 "**옆에 있는 값과 비교해서 더 작은 값을 앞으로 보낸다.**"이다.

**버블 정렬의 순서 따라 가보기**<br>
> 1 10 5 8 7 6 4 3 2 9 <br>
> 1과 10을 비교 후 작은 것을 앞으로 옮긴다. <br>
> 1 10 5 8 7 6 4 3 2 9 <br>
> 10과 5를 비교 후 작은 것을 앞으로 옮긴다. <br>
> 1 5 10 8 7 6 4 3 2 9 <br>
> 이 과정을 반복하면 가장 큰 수인 10이 맨 뒤로 이동한다. <br>
> 1 5 8 7 6 4 3 2 9 10 <br>
> 그럼 이제 제일 큰 수인 10이 맨 뒤에 있으므로 맨 뒤를 제외하고 똑같은 과정을 반복한다. <br>

**코드로 표현하면 아래와 같다.** <br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/83e97abb-7df3-42f7-9958-3ba2399ef5cd)<br>

**그럼 버블 정렬의 시간복잡도를 알아보자.**
> 선택 정렬과 마찬가지로 한 번 반복할 때마다 반복횟수가 하나씩 줄어든다.<br>
> 총 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1번을 탐색하게 된다. <br>
> 선택 정렬과 마찬가지로 탐색의 횟수는 공차가 1, 첫 번째 항이 N, N 번째 항이 1인 등차수열이므로 아래와 같이 나타낼 수 있다. <br>
> <br>
> $N(N+1)/2$ <br>
> <br>
>> 결과적으로 버블 정렬의 시간 복잡도는 $O(N^2)$이다. <br>

**선택 정렬과의 비교**<br>
***1. 선택 정렬***<br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/81815b9b-0149-4c64-9dfa-b76320987921)<br>
***2. 버블 정렬***<br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/9259d495-c672-4010-b360-b1466200058e)<br>
> 선택 정렬은 한차례 전체적으로 비교 후 마지막에 값의 위치를 바꿔준다. <br>
> 하지만 버블 정렬은 비교하면서 동시에 값들의 위치를 서로 바꿔주기 때문에 <br>
> 같은 복잡도를 가졌지만, 실제 수행시간은 버블 정렬이 좀 더 느리다. <br>

<br>
<br>

## 삽입 정렬
```
> 다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.
> 1 10 5 8 7 6 4 3 2 9
```
삽입 정렬의 가장 핵심 아이디어는 "**각 숫자를 적절한 위치에 삽입하면 어떨까?**"이다.<br>
앞에서 말한 선택 정렬과 버블 정렬은 이미 숫자가 오름차순으로 정렬되어 있어도 반드시 반복을 수행했다.<br>
하지만 삽입 정렬은 **필요시에만 위치를 바꾼다.** 그러므로 선택 정렬과 버블 정렬보다 빠르다. <br>

**삽입 정렬의 순서 따라 가보기**<br>
> 삽입 정렬은 **앞에 있는 원소들이 이미 정렬이 되어있다고 가정**을 한다. <br>
> 처음에 1은 정렬이 되어있다고 가정하고 10부터 본다. <br>
> 10은 _ 1 _ 5 8 7 6 4 3 2 9 처럼 1의 앞과 뒤에 들어갈 수 있는데 1보다 크므로 1의 뒤에 있게 된다. <br>
> 그다음인 5는 _ 1 _ 10 _ 8 7 6 4 3 2 9 처럼 3곳에 들어갈 수 있는데 1과 10 사이에 들어간다. <br>
> 그다음인 8은 _ 1 _ 5 _ 10 _ 7 6 5 3 2 9 총 4곳에 들어갈 수 있고, 5와 10 사이에 들어간다. <br>
> 이처럼 특정한 원소에서 앞에 원소들을 살펴보면서 적당한 곳에 들어가는 방식으로 정렬한다. <br>
> <br>
> 이 방식이 유용한 이유에 대해 설명하기 위해 그다음 원소인 6을 보자. <br>
> 6은 전체와 비교가 아닌 앞에 이미 정렬되어 있다고 가정한 1, 5, 7, 8, 10 이랑만 자신을 비교한다. <br>
> 거기에서도 10, 8, 7, 5까지만 비교하면 자신이 5보다는 크기 때문에 5의 오른쪽에 위치하면 된다는 것을 판단할 수 있다. <br>
> 따라서 앞에 정렬된 원소들을 모두 확인하는 것이 아닌 자신이 더 클 때까지만 비교하면 되기 때문에 반복횟수가 작아진다. <br>

**코드로 표현하면 아래와 같다.** <br>
![image](https://github.com/Kimpossible94/TIL/assets/80395024/e301a43b-f464-4d58-98de-b8a459eaa95b) <br>

**그럼 이 삽입 정렬은 얼마나 많은 시간을 잡아먹는지 생각해보자.** <br>
> 최악의 경우에는 앞서 나온 선택 정렬과 버블 정렬과 마찬가지로 <br>
> 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 처럼 나올 수 있다. <br>
> 그래서 시간복잡도는 $O(N^2)$ 이다. <br>
> 하지만 최악의 경우일 뿐이지 나머지 경우에는 연산횟수가 선택 정렬, 버블 정렬보다 적으므로 훨씬 효율적이다. <br>
> <br>
> 아래의 경우를 보자. <br>
> 2 3 4 5 6 7 8 9 10 1 <br>
> 원소들이 오름차순으로 거의 정렬된 상태이다. <br>
> 이렇게 이미 정렬되어있거나 거의 정렬된 상태에 한해서는 어떤 알고리즘보다도 빠르다는 특징이 있다.

<br>
<br>

## 퀵 정렬
위에서 공부한 선택 정렬, 버블 정렬, 삽입 정렬은 시간 복잡도 $O(N^2)$를 가지는 알고리즘이었다.  
사실 이러한 복잡도를 가지는 알고리즘은 데이터가 10만 개만 넘어가도 일반적인 상황에서  
사용하기 매우 어려운 알고리즘이다.  

**퀵 정렬**은 대표적인 **'분할 정복'** 알고리즘으로 평균 속도가 $O(NlogN)$이다.  

---
그럼, $O(NlogN)$이 얼마나 빠른지 알아보자.  
데이터가 2<sup>20</sup>(= 1,000,000)개 만큼있다고 가정하면  
$O(N^2)$의 시간복잡도를 가지는 알고리즘 에서는 $1,000,000 * 1,000,000 = 1,000,000,000,000$번을 계산해야한다.  
하지만 $O(NlogN)$의 시간복잡도를 가지는 알고리즘이라면 $log$의 밑이 2라고 가정한다면  
$1,000,000 * log_2$(2<sup>20</sup>) $= 20,000,000$ 이므로 굉장히 빠르다.  
<br>

퀵 정렬의 가장 핵심 아이디어는 "**특정한 값을 기준으로 반으로 나눈다.**"이다.  
여기에서 "*반으로 나눈다.*"는 원소들을 두집합으로 나눈다는 뜻이다.  

일반적으로 퀵 정렬에서는 기준 값이 있는데, 이를 **피벗(Pivot)** 이라고 한다.  
피벗은 보통 첫 번째 원소를 피벗 값으로 설정하고 사용한다.  
  
**퀵 정렬의 순서 따라 가보기**  
~~~
아래과 같은 배열을 퀵정렬 해보자.  
3 7 8 1 5 9 6 10 2 4  
  
1. |3| 7 8 1 5 9 6 10 2 4  
    3을 피벗 값으로 설정한다.  
2. 이제 왼쪽에서 오른쪽으로, 오른쪽에서 왼쪽으로 이동하며 탐색한다.  
3. 왼쪽에서 오른쪽으로 이동할 때는 피벗 값보다 큰 값을 선택한다. (= 7 선택)  
4. 오른쪽에서 왼쪽으로 이동할 때는 피벗 값보다 작은 값을 선택한다. (= 2 선택)  
5. |3| 2 8 1 5 9 6 10 7 4  
    선택한 큰 값과 작은 값의 위치를 바꿔준다.  
    바뀐뒤에도 피벗값은 그대로 3이다.  
6. 다시 왼쪽에서 오른쪽, 오른쪽에서 왼쪽으로 탐색한다. (= 큰 값 : 8, 작은 값 : 1)  
7. |3| 2 1 8 5 9 6 10 7 4  
    똑같이 위치를 바꿔준다.  
8. 이제 똑같이 다시 탐색을 하는데 큰 값이 8 작은 값이 1 이다.  
    근데 큰 값의 인덱스(= 3)가 작은 값의 인덱스(= 2)보다 크므로 엇갈린 상황이 된다.  
    이런 경우에는 작은 값과 피벗 값의 위치를 바꿔주면 된다.  
9. 1 2 |3| 8 5 9 6 10 7 4  
    그렇다면 이렇게 바뀌면서 피벗 값을 기준으로 양쪽으로 분할이 되는데
    이렇게 분할 됬을 때, 왼쪽은 피벗 값보다 작은 값, 오른쪽은 큰 값이 있다는 특징이 있다.

~~~
