# 숫자 블록
## 문제 설명
그렙시에는 숫자 0이 적힌 블록들이 설치된 도로에 다른 숫자가 적힌 블록들을 설치하기로 하였습니다. 숫자 블록을 설치하는 규칙은 다음과 같습니다.

블록에 적힌 번호가 n 일 때, 가장 첫 블록은 n * 2번째 위치에 설치합니다. 그 다음은 n * 3, 그 다음은 n * 4, ...위치에 설치합니다. 기존에 설치된 블록은 빼고 새로운 블록을 집어넣습니다.

블록은 1이 적힌 블록부터 숫자를 1씩 증가시키며 순서대로 설치합니다. 예를 들어 1이 적힌 블록은 2, 3, 4, 5, ... 인 위치에 우선 설치합니다. 그 다음 2가 적힌 블록은 4, 6, 8, 10, ... 인 위치에 설치하고, 3이 적힌 블록은 6, 9, 12... 인 위치에 설치합니다.

이렇게 3이 적힌 블록까지 설치하고 나면 첫 10개의 블록에 적힌 번호는 [0, 1, 1, 2, 1, 3, 1, 2, 3, 2]가 됩니다.

그렙시는 길이가 1,000,000,000인 도로에 1부터 10,000,000까지의 숫자가 적힌 블록들을 이용해 위의 규칙대로 모두 설치 했습니다.

그렙시의 시장님은 특정 구간에 어떤 블록이 깔려 있는지 알고 싶습니다.

구간을 나타내는 두 정수 begin, end 가 매개변수로 주어 질 때, 그 구간에 깔려 있는 블록의 숫자 배열을 return하는 solution 함수를 완성해 주세요.

## 제한 조건
* 1 ≤ begin ≤ end ≤ 1,000,000,000
* end - begin ≤ 5,000

## 풀이
### 나의 풀이
약수를 통해서 구하면 된다는 걸 깨닳아서 begin부터 end까지 숫자에 대한 약수를 구하는 방식으로 했다.  
자기자신은 다음부터 적용되므로 2부터 나누어서 0으로 떨어지는 값을 넣는다.

#### 초기 코드
```java
class Solution {
    public int[] solution(long begin, long end) {
        int[] arr = new int[(int) end];
        for (int i = (int) begin; i <= end; i++) {
            arr[i-1] = 1;
            for (int j = 2; j <= i; j++) {
                if(i%j == 0) {
                    arr[i-1] = i/j; break;
                }
            }
        }
        arr[0] = 0;

        int[] result = new int[(int) (end-begin+1)];
        int idx = 0;
        for (int i = (int) begin-1; i < arr.length; i++) {
            result[idx] = arr[i];
            idx++;
        }

        return result;
    }
}
```

위 코드는 테스트도 통과하지 못했고, 소수의 경우 해당 수까지 나누기를 반복하므로 효율성이 많이 떨어진다.  
그래서 소수인지 판별하는 로직을 넣으면 효율적으로 바뀔 것이라 생각해 아래처럼 코드를 바꾸었다.
#### 수정 코드
```java
class Solution {
    public int[] solution(long begin, long end) {
        int beginInt = (int) begin;
        int endInt = (int) end;
        int[] result = new int[endInt-beginInt+1];

        for (int i = beginInt; i < endInt + 1; i++) {
            result[i-beginInt] = 1;

            // 에라토스테네스의 체
            for (int j = 2; j <= Math.sqrt(i); j++) {
                if (i % j == 0) { // 소수가 아님
                    if(i / j > 10000000) { // 몫이 10,000,000을 넘으면 나눈 숫자를 대입
                        result[i-beginInt] = j;
                    } else {
                        result[i-beginInt] = i / j; // 10,000,000 이하라면 나눈 몫을 대입
                        break;
                    }
                }
            }
        }
        if (beginInt == 1) result[0] = 0;
        return result;
    }
}
```
이렇게 수정하는데까지 문제가 있었다.  
숫자 블록이 10,000,000 까지가 제한이라서 나눈 몫이 10,000,000이 넘어가는 경우에 대한 부분을 생각하지 못해서 오래 걸렸다.  

그리고 몫이 10,000,000을 넘어간다고 무조건 값을 넣지 않으면 1이 들어가므로 문제가 생긴다. (테스트 케이스 13번에서 걸림)  

즉, 몫(i/j)이 10,000,000을 넘어가도 나눠지기만 한다면 나눈수(j)도 약수이므로 해당 수를 넣어주는 부분을 추가해서 문제를 해결했다.